import{u as Ne,j as i,F as w,r as g,T as Ce,D as $e,L as Re,a as qe}from"./iframe-Cw7dogRh.js";import{M as Oe,u as je,a as Ie,C as W,N as Y,b as T,z as Se,n as X,c as De,P as x,D as $,B as Le,d as me,g as He,e as Ve,f as Ae,h as ze,i as We,S as Ye,j as Fe,k as ee,l as Ze,m as G,o as U}from"./node-DDPH6A4P.js";import"./index-BVv2e41P.js";const Be=200,Ke=100,ue=()=>{const n=Ne();return i.jsx(Oe,{maskColor:n.minimap.mask,nodeColor:n.minimap.node,style:{width:Be,height:Ke,background:n.minimap.selectionArea}})};ue.__docgenInfo={description:"",methods:[],displayName:"MiniMap"};const F={duration:500},Xe=X(De)`
  box-shadow: unset;
  display: flex;
  flex-direction: row;
  align-items: flex-end;
  gap: ${T[300]}px;
  font-size: 11px;
  color: ${n=>n.theme.controls.zoomText};
  font-family: ${Se.code};
`,Ge=X.div`
  > .react-flow__controls-button {
    background-color: ${n=>n.theme.controls.background};
    border: 1px solid ${w.gray.base};
    height: ${T[600]+T[100]}px;
    width: ${T[600]+T[100]}px;
    color: ${n=>n.theme.controls.buttonColor};
  }
  > .react-flow__controls-button:hover {
    background-color: ${n=>n.theme.controls.backgroundHover};
  }
  > *:first-of-type {
    border-top-left-radius: ${T[150]}px;
    border-top-right-radius: ${T[150]}px;
  }
  > *:last-of-type {
    border-bottom-left-radius: ${T[150]}px;
    border-bottom-right-radius: ${T[150]}px;
  }
`,pe=({title:n})=>{const{zoomIn:e,zoomOut:t,fitView:o}=je(),{zoom:s}=Ie();return i.jsxs(Xe,{position:"bottom-left",showFitView:!1,showInteractive:!1,showZoom:!1,children:[i.jsxs(Ge,{children:[i.jsx(W,{onClick:()=>e(F),children:i.jsx(Y,{glyph:"Plus"})}),i.jsx(W,{onClick:()=>t(F),children:i.jsx(Y,{glyph:"Minus"})}),i.jsx(W,{onClick:()=>o(F),children:i.jsx(Y,{glyph:"FullScreenEnter"})})]}),`${Math.round(s*100)}%${n?`  ${n}`:""}`]})};pe.__docgenInfo={description:"",methods:[],displayName:"Controls",props:{title:{required:!1,tsType:{name:"string"},description:""}}};const Ue=(n,e)=>{const t=g.useMemo(()=>n.map(s=>{const{title:a,fields:r,borderVariant:d,disabled:l,connectable:m,...c}=s;return{...c,connectable:m??!1,data:{title:a,disabled:l,fields:r,borderVariant:d}}}),[n]),o=g.useMemo(()=>e.map(s=>({...s,markerStart:`start-${s.markerStart}`,markerEnd:`end-${s.markerEnd}`,type:s.source===s.target?"selfReferencingEdge":"floatingEdge"})),[e]);return{initialNodes:t,initialEdges:o}},ne=(n,e)=>{const{width:t,height:o}=n.measured??{width:0,height:0},s=e.position,a=(t??0)/2,r=(o??0)/2,d=n.position.x+a,l=n.position.y+r,m=s.x+a,c=s.y+r,u=(m-d)/(2*a)-(c-l)/(2*r),p=(m-d)/(2*a)+(c-l)/(2*r),h=1/(Math.abs(u)+Math.abs(p)),y=h*u,f=h*p,b=a*(y+f)+d,_=r*(-y+f)+l;return{x:b,y:_}},te=(n,e)=>{var d,l;const t={...n.position,...n},o=Math.round(t.x),s=Math.round(t.y),a=Math.round(e.x),r=Math.round(e.y);return a<=o+1?x.Left:a>=o+(((d=t.measured)==null?void 0:d.width)??0)-1?x.Right:r<=s+1?x.Top:r>=t.y+(((l=t.measured)==null?void 0:l.height)??0)-1?x.Bottom:x.Top},oe=(n,{x:e,y:t})=>{const o=$/2;switch(n){case x.Left:return{x:e-o,y:t};case x.Top:return{x:e,y:t-o};case x.Right:return{x:e+o,y:t};case x.Bottom:return{x:e,y:t+o};default:return{x:e,y:t}}},Qe=(n,e)=>{const t=ne(n,e),o=ne(e,n),s=te(n,t),a=te(e,o),r=oe(s,t),d=oe(a,o);return{sx:r.x,sy:r.y,tx:d.x,ty:d.y,sourcePos:s,targetPos:a}},se=(n,e)=>n?e==null?void 0:e.replace(/'\)/,"-selected')"):e,Q=({markerStart:n,markerEnd:e,selected:t,...o})=>i.jsx(Le,{markerEnd:se(t,e),markerStart:se(t,n),style:{stroke:t?w.blue.base:w.gray.base},...o});Q.__docgenInfo={description:"",methods:[],displayName:"Edge",props:{selected:{required:!1,tsType:{name:"boolean"},description:""},path:{required:!0,tsType:{name:"string"},description:""}},composes:["SVGAttributes"]};const ge=({id:n,source:e,target:t,markerEnd:o,markerStart:s,selected:a})=>{const r=me(),{sourceNode:d,targetNode:l}=g.useMemo(()=>{const b=r.find(M=>M.id===e),_=r.find(M=>M.id===t);return{sourceNode:b,targetNode:_}},[r,e,t]);if(!d||!l)return null;const{sx:m,sy:c,tx:u,ty:p,sourcePos:h,targetPos:y}=Qe(d,l),[f]=He({sourceX:m,sourceY:c,sourcePosition:h,targetPosition:y,targetX:u,targetY:p});return i.jsx(Q,{"data-testid":`floating-edge-${n}`,markerEnd:o,markerStart:s,path:f,id:n,selected:a})};ge.__docgenInfo={description:"",methods:[],displayName:"FloatingEdge"};const Z=Math.PI,B=2*Z,C=1e-6,Je=B-C;function he(n){this._+=n[0];for(let e=1,t=n.length;e<t;++e)this._+=arguments[e]+n[e]}function en(n){let e=Math.floor(n);if(!(e>=0))throw new Error(`invalid digits: ${n}`);if(e>15)return he;const t=10**e;return function(o){this._+=o[0];for(let s=1,a=o.length;s<a;++s)this._+=Math.round(arguments[s]*t)/t+o[s]}}class ye{constructor(e){this._x0=this._y0=this._x1=this._y1=null,this._="",this._append=e==null?he:en(e)}moveTo(e,t){this._append`M${this._x0=this._x1=+e},${this._y0=this._y1=+t}`}closePath(){this._x1!==null&&(this._x1=this._x0,this._y1=this._y0,this._append`Z`)}lineTo(e,t){this._append`L${this._x1=+e},${this._y1=+t}`}quadraticCurveTo(e,t,o,s){this._append`Q${+e},${+t},${this._x1=+o},${this._y1=+s}`}bezierCurveTo(e,t,o,s,a,r){this._append`C${+e},${+t},${+o},${+s},${this._x1=+a},${this._y1=+r}`}arcTo(e,t,o,s,a){if(e=+e,t=+t,o=+o,s=+s,a=+a,a<0)throw new Error(`negative radius: ${a}`);let r=this._x1,d=this._y1,l=o-e,m=s-t,c=r-e,u=d-t,p=c*c+u*u;if(this._x1===null)this._append`M${this._x1=e},${this._y1=t}`;else if(p>C)if(!(Math.abs(u*l-m*c)>C)||!a)this._append`L${this._x1=e},${this._y1=t}`;else{let h=o-r,y=s-d,f=l*l+m*m,b=h*h+y*y,_=Math.sqrt(f),M=Math.sqrt(p),k=a*Math.tan((Z-Math.acos((f+p-b)/(2*_*M)))/2),N=k/M,R=k/_;Math.abs(N-1)>C&&this._append`L${e+N*c},${t+N*u}`,this._append`A${a},${a},0,0,${+(u*h>c*y)},${this._x1=e+R*l},${this._y1=t+R*m}`}}arc(e,t,o,s,a,r){if(e=+e,t=+t,o=+o,r=!!r,o<0)throw new Error(`negative radius: ${o}`);let d=o*Math.cos(s),l=o*Math.sin(s),m=e+d,c=t+l,u=1^r,p=r?s-a:a-s;this._x1===null?this._append`M${m},${c}`:(Math.abs(this._x1-m)>C||Math.abs(this._y1-c)>C)&&this._append`L${m},${c}`,o&&(p<0&&(p=p%B+B),p>Je?this._append`A${o},${o},0,1,${u},${e-d},${t-l}A${o},${o},0,1,${u},${this._x1=m},${this._y1=c}`:p>C&&this._append`A${o},${o},0,${+(p>=Z)},${u},${this._x1=e+o*Math.cos(a)},${this._y1=t+o*Math.sin(a)}`)}rect(e,t,o,s){this._append`M${this._x0=this._x1=+e},${this._y0=this._y1=+t}h${o=+o}v${+s}h${-o}Z`}toString(){return this._}}function fe(){return new ye}fe.prototype=ye.prototype;const ve=({id:n,source:e,markerEnd:t,markerStart:o,selected:s})=>{var O,j;const a=me(),{sourceNode:r}=g.useMemo(()=>({sourceNode:a.find(A=>A.id===e)}),[a,e]);if(!r)return null;const d=(((O=r.measured)==null?void 0:O.width)||0)/2,l=(((j=r.measured)==null?void 0:j.height)||0)/2,m=d+40,c=30,u=l+c,p=r.position.x+d,h=r.position.y-$/2,y=p,f=h-c,b=p+m,_=f,M=b,k=_+u,N=b-m+d+$/2,R=k,P=fe();return P.moveTo(p,h),P.lineTo(y,f),P.lineTo(b,f),P.lineTo(M,k),P.lineTo(N,R),i.jsx(Q,{"data-testid":`self-referencing-edge-${n}`,markerEnd:t,markerStart:o,path:P.toString(),selected:s,id:n})};ve.__docgenInfo={description:"",methods:[],displayName:"SelfReferencingEdge"};const Ee=({children:n,id:e,...t})=>i.jsx("marker",{id:e,markerHeight:$,markerWidth:$,refX:$/2,refY:$/2,fill:w.gray.base,...t,children:n});Ee.__docgenInfo={description:"",methods:[],displayName:"Marker"};const I=n=>g.createElement("svg",{width:15,height:15,viewBox:"0 0 15 15",xmlns:"http://www.w3.org/2000/svg",...n},g.createElement("path",{fillRule:"evenodd",clipRule:"evenodd",d:"M6 7V6.99515H6.00982L15 0.357803V1.6008L7.69345 6.99515H15V7V7.99515V8H7.68985L15 13.397V14.64L6.00622 8H6V8.00006H4V13H3V8.00006H0V8V7.00006V7H3V2H4V7H6Z"})),S=n=>g.createElement("svg",{width:15,height:15,viewBox:"0 0 15 15",xmlns:"http://www.w3.org/2000/svg",...n},g.createElement("path",{d:"M6 8.00485V7.99994H0V6.99994H6V7.00485H6.00456L6.00283 7.0025L15 0.359985V1.60299L7.68328 7.00485H15V8.00485H7.69345L15 13.3992V14.6422L6.00982 8.00485H6Z"})),D=n=>g.createElement("svg",{width:15,height:15,viewBox:"0 0 15 15",xmlns:"http://www.w3.org/2000/svg",...n},g.createElement("path",{d:"M4 8V13H3V8L0 8V7L3 7V2H4V7L15 7V8L4 8Z"})),nn={"start-oneOrMany":{component:i.jsx(I,{}),orient:"auto-start-reverse"},"start-oneOrMany-selected":{component:i.jsx(I,{}),orient:"auto-start-reverse",fill:w.blue.base},"end-oneOrMany":{component:i.jsx(I,{}),orient:"auto"},"end-oneOrMany-selected":{component:i.jsx(I,{}),orient:"auto",fill:w.blue.base},"start-one":{component:i.jsx(D,{}),orient:"auto-start-reverse"},"start-one-selected":{component:i.jsx(D,{}),orient:"auto-start-reverse",fill:w.blue.base},"end-one":{component:i.jsx(D,{}),orient:"auto"},"end-one-selected":{component:i.jsx(D,{}),orient:"auto",fill:w.blue.base},"start-many":{component:i.jsx(S,{}),orient:"auto-start-reverse"},"start-many-selected":{component:i.jsx(S,{}),orient:"auto-start-reverse",fill:w.blue.base},"end-many":{component:i.jsx(S,{}),orient:"auto"},"end-many-selected":{component:i.jsx(S,{}),orient:"auto",fill:w.blue.base}},we=()=>i.jsx("svg",{children:i.jsx("defs",{children:Object.entries(nn).map(([n,{component:e,...t}])=>i.jsx(Ee,{"data-testid":n,id:n,...t,children:e},n))})});we.__docgenInfo={description:"",methods:[],displayName:"MarkerList"};const be=({fromX:n,fromY:e,toX:t,toY:o})=>{const[s]=Ve({sourceX:n,sourceY:e,targetX:t,targetY:o});return i.jsxs("g",{children:[i.jsx("circle",{cx:n,cy:e,fill:w.blue.base,r:4}),i.jsx("path",{"data-testid":"connection-line",style:{animation:"dashdraw 0.5s linear infinite"},d:s,fill:"none",stroke:w.blue.base,strokeDasharray:5,strokeWidth:2})]})};be.__docgenInfo={description:"",methods:[],displayName:"ConnectionLine"};const V=n=>{const{data:e,...t}=n;return{...t,...e,type:n.type}},q=n=>n.map(e=>V(e)),_e=n=>{const{markerStart:e,markerEnd:t,...o}=n;return{...o,markerStart:e==null?void 0:e.replace(/^start-/,""),markerEnd:t==null?void 0:t.replace(/^end-/,"")}},tn=n=>n.map(e=>_e(e)),on=3,sn=.1,rn={hideAttribution:!0},an=X.div`
  height: 100%;
  background: ${n=>n.theme.background};
`,dn={table:ee,collection:ee},ln={floatingEdge:ge,selfReferencingEdge:ve},Me=({title:n,nodes:e,edges:t,onConnect:o,id:s,onNodeContextMenu:a,onNodeDrag:r,onNodeDragStop:d,onEdgeClick:l,onSelectionDragStop:m,onSelectionContextMenu:c,onSelectionChange:u,...p})=>{const{initialNodes:h,initialEdges:y}=Ue(e,t),[f,b,_]=Ae(h),[M,k,N]=ze(y);g.useEffect(()=>{b(h)},[h]),g.useEffect(()=>{k(y)},[y]);const R=g.useCallback((v,E)=>{a==null||a(v,V(E))},[a]),P=g.useCallback((v,E,z)=>{r==null||r(v,V(E),q(z))},[r]),O=g.useCallback((v,E,z)=>{d==null||d(v,V(E),q(z))},[d]),j=g.useCallback((v,E)=>{m==null||m(v,q(E))},[m]),J=g.useCallback((v,E)=>{l==null||l(v,_e(E))},[l]),A=g.useCallback((v,E)=>{c==null||c(v,q(E))},[c]),ke=g.useCallback(({nodes:v,edges:E})=>{u==null||u({nodes:q(v),edges:tn(E)})},[u]);return i.jsx(an,{children:i.jsxs(We,{id:s,deleteKeyCode:null,proOptions:rn,maxZoom:on,minZoom:sn,nodeTypes:dn,edgeTypes:ln,nodes:f,onlyRenderVisibleElements:!0,edges:M,connectionLineComponent:be,connectionMode:Fe.Loose,onNodesChange:_,onEdgesChange:N,selectionMode:Ye.Partial,nodesDraggable:!0,onConnect:o,onNodeContextMenu:R,onNodeDrag:P,onNodeDragStop:O,onSelectionDragStop:j,onEdgeClick:J,onSelectionContextMenu:A,onSelectionChange:ke,...p,children:[i.jsx(we,{}),i.jsx(Ze,{id:s}),i.jsx(pe,{title:n}),i.jsx(ue,{})]})})};Me.__docgenInfo={description:"",methods:[],displayName:"Canvas",props:{id:{required:!1,tsType:{name:"string"},description:"Unique identifier for the diagram instance."},title:{required:!1,tsType:{name:"string"},description:"Title used for the diagram, displayed next to the controls."},isDarkMode:{required:!1,tsType:{name:"boolean"},description:"Whether the diagram should render in dark mode."},nodes:{required:!0,tsType:{name:"Array",elements:[{name:"NodeProps"}],raw:"NodeProps[]"},description:"Nodes to render in the diagram."},edges:{required:!0,tsType:{name:"Array",elements:[{name:"EdgeProps"}],raw:"EdgeProps[]"},description:"Edges to render in the diagram."},className:{required:!1,tsType:{name:"string"},description:"Optional CSS class to apply to the React Flow container."},onConnect:{required:!1,tsType:{name:"signature",type:"function",raw:"(connection: Connection) => void",signature:{arguments:[{type:{name:"Connection"},name:"connection"}],return:{name:"void"}}},description:"Callback when a new connection is made between nodes."},onPaneClick:{required:!1,tsType:{name:"signature",type:"function",raw:"(event: ReactMouseEvent) => void",signature:{arguments:[{type:{name:"ReactMouseEvent"},name:"event"}],return:{name:"void"}}},description:"Callback when the user clicks on the empty canvas."},onEdgeClick:{required:!1,tsType:{name:"signature",type:"function",raw:"(event: ReactMouseEvent, edge: EdgeProps) => void",signature:{arguments:[{type:{name:"ReactMouseEvent"},name:"event"},{type:{name:"EdgeProps"},name:"edge"}],return:{name:"void"}}},description:"Callback when the user clicks on an edge."},onNodeContextMenu:{required:!1,tsType:{name:"signature",type:"function",raw:"(event: ReactMouseEvent, node: NodeProps) => void",signature:{arguments:[{type:{name:"ReactMouseEvent"},name:"event"},{type:{name:"NodeProps"},name:"node"}],return:{name:"void"}}},description:"Callback when the user right-clicks on a node."},onSelectionContextMenu:{required:!1,tsType:{name:"signature",type:"function",raw:"(event: ReactMouseEvent, nodes: NodeProps[]) => void",signature:{arguments:[{type:{name:"ReactMouseEvent"},name:"event"},{type:{name:"Array",elements:[{name:"NodeProps"}],raw:"NodeProps[]"},name:"nodes"}],return:{name:"void"}}},description:"Callback when the user right-clicks with multiple elements selected."},onSelectionChange:{required:!1,tsType:{name:"signature",type:"function",raw:"(params: { nodes: NodeProps[]; edges: EdgeProps[] }) => void",signature:{arguments:[{type:{name:"signature",type:"object",raw:"{ nodes: NodeProps[]; edges: EdgeProps[] }",signature:{properties:[{key:"nodes",value:{name:"Array",elements:[{name:"NodeProps"}],raw:"NodeProps[]",required:!0}},{key:"edges",value:{name:"Array",elements:[{name:"EdgeProps"}],raw:"EdgeProps[]",required:!0}}]}},name:"params"}],return:{name:"void"}}},description:"Callback when the selection of nodes or edges changes."},onSelectionDragStop:{required:!1,tsType:{name:"signature",type:"function",raw:"(event: ReactMouseEvent, nodes: NodeProps[]) => void",signature:{arguments:[{type:{name:"ReactMouseEvent"},name:"event"},{type:{name:"Array",elements:[{name:"NodeProps"}],raw:"NodeProps[]"},name:"nodes"}],return:{name:"void"}}},description:"Callback when dragging a selected group of elements ends."},onNodeDrag:{required:!1,tsType:{name:"signature",type:"function",raw:"(event: ReactMouseEvent, node: NodeProps, nodes: NodeProps[]) => void",signature:{arguments:[{type:{name:"ReactMouseEvent"},name:"event"},{type:{name:"NodeProps"},name:"node"},{type:{name:"Array",elements:[{name:"NodeProps"}],raw:"NodeProps[]"},name:"nodes"}],return:{name:"void"}}},description:"Callback when a node is dragged."},onNodeDragStop:{required:!1,tsType:{name:"signature",type:"function",raw:"(event: ReactMouseEvent, node: NodeProps, nodes: NodeProps[]) => void",signature:{arguments:[{type:{name:"ReactMouseEvent"},name:"event"},{type:{name:"NodeProps"},name:"node"},{type:{name:"Array",elements:[{name:"NodeProps"}],raw:"NodeProps[]"},name:"nodes"}],return:{name:"void"}}},description:"Callback when a node finishes being dragged."},onConnectStart:{required:!1,tsType:{name:"signature",type:"function",raw:`(
  event: MouseEvent | TouchEvent,
  params: { nodeId?: string | null; handleType: HandleType | null; handleId?: string | null },
) => void`,signature:{arguments:[{type:{name:"union",raw:"MouseEvent | TouchEvent",elements:[{name:"MouseEvent"},{name:"TouchEvent"}]},name:"event"},{type:{name:"signature",type:"object",raw:"{ nodeId?: string | null; handleType: HandleType | null; handleId?: string | null }",signature:{properties:[{key:"nodeId",value:{name:"union",raw:"string | null",elements:[{name:"string"},{name:"null"}],required:!1}},{key:"handleType",value:{name:"union",raw:"HandleType | null",elements:[{name:"HandleType"},{name:"null"}],required:!0}},{key:"handleId",value:{name:"union",raw:"string | null",elements:[{name:"string"},{name:"null"}],required:!1}}]}},name:"params"}],return:{name:"void"}}},description:"Callback when a new connection starts (e.g. user begins dragging from a handle)."},panOnDrag:{required:!1,tsType:{name:"union",raw:"boolean | number[]",elements:[{name:"boolean"},{name:"Array",elements:[{name:"number"}],raw:"number[]"}]},description:"Whether the diagram should pan when dragging elements."},fitViewOptions:{required:!1,tsType:{name:"FitViewOptions"},description:"Options to control how `fitView` behaves."},selectionKeyCode:{required:!1,tsType:{name:"union",raw:"string | null",elements:[{name:"string"},{name:"null"}]},description:"Key code used to trigger selection mode."},multiSelectionKeyCode:{required:!1,tsType:{name:"Array",elements:[{name:"string"}],raw:"string[]"},description:"Key code used to enable multi-selection mode."},zoomOnPinch:{required:!1,tsType:{name:"boolean"},description:"Whether to allow zooming via pinch gestures."},zoomOnScroll:{required:!1,tsType:{name:"boolean"},description:"Whether to allow zooming via scroll."},maxZoom:{required:!1,tsType:{name:"number"},description:"Maximum allowed zoom level."},minZoom:{required:!1,tsType:{name:"number"},description:"Minimum allowed zoom level."},onlyRenderVisibleElements:{required:!1,tsType:{name:"boolean"},description:`Whether to only render elements that are currently visible in the viewport.
This can improve performance for large diagrams.
@defaults true`}}};const Te=({isDarkMode:n,...e})=>i.jsx(Ce,{theme:n?$e:Re,children:i.jsx(qe,{darkMode:n,children:i.jsx(Me,{...e})})});Te.__docgenInfo={description:"",methods:[],displayName:"Diagram",props:{id:{required:!1,tsType:{name:"string"},description:"Unique identifier for the diagram instance."},title:{required:!1,tsType:{name:"string"},description:"Title used for the diagram, displayed next to the controls."},isDarkMode:{required:!1,tsType:{name:"boolean"},description:"Whether the diagram should render in dark mode."},nodes:{required:!0,tsType:{name:"Array",elements:[{name:"NodeProps"}],raw:"NodeProps[]"},description:"Nodes to render in the diagram."},edges:{required:!0,tsType:{name:"Array",elements:[{name:"EdgeProps"}],raw:"EdgeProps[]"},description:"Edges to render in the diagram."},className:{required:!1,tsType:{name:"string"},description:"Optional CSS class to apply to the React Flow container."},onConnect:{required:!1,tsType:{name:"signature",type:"function",raw:"(connection: Connection) => void",signature:{arguments:[{type:{name:"Connection"},name:"connection"}],return:{name:"void"}}},description:"Callback when a new connection is made between nodes."},onPaneClick:{required:!1,tsType:{name:"signature",type:"function",raw:"(event: ReactMouseEvent) => void",signature:{arguments:[{type:{name:"ReactMouseEvent"},name:"event"}],return:{name:"void"}}},description:"Callback when the user clicks on the empty canvas."},onEdgeClick:{required:!1,tsType:{name:"signature",type:"function",raw:"(event: ReactMouseEvent, edge: EdgeProps) => void",signature:{arguments:[{type:{name:"ReactMouseEvent"},name:"event"},{type:{name:"EdgeProps"},name:"edge"}],return:{name:"void"}}},description:"Callback when the user clicks on an edge."},onNodeContextMenu:{required:!1,tsType:{name:"signature",type:"function",raw:"(event: ReactMouseEvent, node: NodeProps) => void",signature:{arguments:[{type:{name:"ReactMouseEvent"},name:"event"},{type:{name:"NodeProps"},name:"node"}],return:{name:"void"}}},description:"Callback when the user right-clicks on a node."},onSelectionContextMenu:{required:!1,tsType:{name:"signature",type:"function",raw:"(event: ReactMouseEvent, nodes: NodeProps[]) => void",signature:{arguments:[{type:{name:"ReactMouseEvent"},name:"event"},{type:{name:"Array",elements:[{name:"NodeProps"}],raw:"NodeProps[]"},name:"nodes"}],return:{name:"void"}}},description:"Callback when the user right-clicks with multiple elements selected."},onSelectionChange:{required:!1,tsType:{name:"signature",type:"function",raw:"(params: { nodes: NodeProps[]; edges: EdgeProps[] }) => void",signature:{arguments:[{type:{name:"signature",type:"object",raw:"{ nodes: NodeProps[]; edges: EdgeProps[] }",signature:{properties:[{key:"nodes",value:{name:"Array",elements:[{name:"NodeProps"}],raw:"NodeProps[]",required:!0}},{key:"edges",value:{name:"Array",elements:[{name:"EdgeProps"}],raw:"EdgeProps[]",required:!0}}]}},name:"params"}],return:{name:"void"}}},description:"Callback when the selection of nodes or edges changes."},onSelectionDragStop:{required:!1,tsType:{name:"signature",type:"function",raw:"(event: ReactMouseEvent, nodes: NodeProps[]) => void",signature:{arguments:[{type:{name:"ReactMouseEvent"},name:"event"},{type:{name:"Array",elements:[{name:"NodeProps"}],raw:"NodeProps[]"},name:"nodes"}],return:{name:"void"}}},description:"Callback when dragging a selected group of elements ends."},onNodeDrag:{required:!1,tsType:{name:"signature",type:"function",raw:"(event: ReactMouseEvent, node: NodeProps, nodes: NodeProps[]) => void",signature:{arguments:[{type:{name:"ReactMouseEvent"},name:"event"},{type:{name:"NodeProps"},name:"node"},{type:{name:"Array",elements:[{name:"NodeProps"}],raw:"NodeProps[]"},name:"nodes"}],return:{name:"void"}}},description:"Callback when a node is dragged."},onNodeDragStop:{required:!1,tsType:{name:"signature",type:"function",raw:"(event: ReactMouseEvent, node: NodeProps, nodes: NodeProps[]) => void",signature:{arguments:[{type:{name:"ReactMouseEvent"},name:"event"},{type:{name:"NodeProps"},name:"node"},{type:{name:"Array",elements:[{name:"NodeProps"}],raw:"NodeProps[]"},name:"nodes"}],return:{name:"void"}}},description:"Callback when a node finishes being dragged."},onConnectStart:{required:!1,tsType:{name:"signature",type:"function",raw:`(
  event: MouseEvent | TouchEvent,
  params: { nodeId?: string | null; handleType: HandleType | null; handleId?: string | null },
) => void`,signature:{arguments:[{type:{name:"union",raw:"MouseEvent | TouchEvent",elements:[{name:"MouseEvent"},{name:"TouchEvent"}]},name:"event"},{type:{name:"signature",type:"object",raw:"{ nodeId?: string | null; handleType: HandleType | null; handleId?: string | null }",signature:{properties:[{key:"nodeId",value:{name:"union",raw:"string | null",elements:[{name:"string"},{name:"null"}],required:!1}},{key:"handleType",value:{name:"union",raw:"HandleType | null",elements:[{name:"HandleType"},{name:"null"}],required:!0}},{key:"handleId",value:{name:"union",raw:"string | null",elements:[{name:"string"},{name:"null"}],required:!1}}]}},name:"params"}],return:{name:"void"}}},description:"Callback when a new connection starts (e.g. user begins dragging from a handle)."},panOnDrag:{required:!1,tsType:{name:"union",raw:"boolean | number[]",elements:[{name:"boolean"},{name:"Array",elements:[{name:"number"}],raw:"number[]"}]},description:"Whether the diagram should pan when dragging elements."},fitViewOptions:{required:!1,tsType:{name:"FitViewOptions"},description:"Options to control how `fitView` behaves."},selectionKeyCode:{required:!1,tsType:{name:"union",raw:"string | null",elements:[{name:"string"},{name:"null"}]},description:"Key code used to trigger selection mode."},multiSelectionKeyCode:{required:!1,tsType:{name:"Array",elements:[{name:"string"}],raw:"string[]"},description:"Key code used to enable multi-selection mode."},zoomOnPinch:{required:!1,tsType:{name:"boolean"},description:"Whether to allow zooming via pinch gestures."},zoomOnScroll:{required:!1,tsType:{name:"boolean"},description:"Whether to allow zooming via scroll."},maxZoom:{required:!1,tsType:{name:"number"},description:"Maximum allowed zoom level."},minZoom:{required:!1,tsType:{name:"number"},description:"Minimum allowed zoom level."},onlyRenderVisibleElements:{required:!1,tsType:{name:"boolean"},description:`Whether to only render elements that are currently visible in the viewport.
This can improve performance for large diagrams.
@defaults true`}}};const xe={id:"orders",type:"table",position:{x:100,y:100},measured:{width:G,height:U*2},title:"orders",fields:[{name:"ORDER_ID",type:"varchar",glyphs:["key"]},{name:"SUPPLIER_ID",type:"varchar",glyphs:["link"]}]},Pe={id:"employees",type:"collection",position:{x:300,y:300},measured:{width:G,height:U*4},title:"employees",fields:[{name:"employeeId",type:"objectId",glyphs:["key"]},{name:"employeeDetail",type:"{}"},{name:"firstName",type:"string",depth:1},{name:"lastName",type:"string",depth:1}]},cn={id:"employee_territories",type:"table",position:{x:400,y:100},measured:{width:G,height:U*4},title:"employee_territories",fields:[{name:"employeeId",type:"string",glyphs:["key"]},{name:"employeeTerritory",type:"string",glyphs:["key"]}]},K={id:"employees-to-orders",source:"employees",target:"orders",markerEnd:"one",markerStart:"many"},mn={id:"employees-to-employees",source:"employees",target:"employees",markerEnd:"one",markerStart:"many"},hn={title:"Diagram",component:Te,args:{title:"MongoDB Diagram",isDarkMode:!0,edges:[K,mn],nodes:[xe,Pe,cn]}},L={},H={decorators:[(n,e)=>{const[t,o]=g.useState(e.args.edges),s=r=>{o([...t.filter(d=>d.source===r.source&&d.source===r.target),{...K,source:r.source,target:r.target,animated:!0,selected:!0}])},a=()=>{o(t.filter(r=>r.id!==K.id))};return n({...e,args:{...e.args,edges:t,onPaneClick:a,onConnect:s}})}],args:{title:"MongoDB Diagram",isDarkMode:!0,edges:[],nodes:[{...xe,connectable:!0},{...Pe,connectable:!0}]}};var re,ae,ie;L.parameters={...L.parameters,docs:{...(re=L.parameters)==null?void 0:re.docs,source:{originalSource:"{}",...(ie=(ae=L.parameters)==null?void 0:ae.docs)==null?void 0:ie.source}}};var de,le,ce;H.parameters={...H.parameters,docs:{...(de=H.parameters)==null?void 0:de.docs,source:{originalSource:`{
  decorators: [(Story, context) => {
    const [edges, setEdges] = useState<EdgeProps[]>(context.args.edges);
    const onConnect = (connection: Connection) => {
      setEdges([...edges.filter(edge => edge.source === connection.source && edge.source === connection.target), {
        ...ORDERS_TO_EMPLOYEES_EDGE,
        source: connection.source,
        target: connection.target,
        animated: true,
        selected: true
      }]);
    };
    const onPaneClick = () => {
      setEdges(edges.filter(edge => edge.id !== ORDERS_TO_EMPLOYEES_EDGE.id));
    };
    return Story({
      ...context,
      args: {
        ...context.args,
        edges,
        onPaneClick,
        onConnect
      }
    });
  }],
  args: {
    title: 'MongoDB Diagram',
    isDarkMode: true,
    edges: [],
    nodes: [{
      ...ORDERS_NODE,
      connectable: true
    }, {
      ...EMPLOYEES_NODE,
      connectable: true
    }]
  }
}`,...(ce=(le=H.parameters)==null?void 0:le.docs)==null?void 0:ce.source}}};const yn=["BasicDiagram","DiagramWithConnectableNodes"];export{L as BasicDiagram,H as DiagramWithConnectableNodes,yn as __namedExportsOrder,hn as default};
